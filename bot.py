import logging
import asyncio
import nest_asyncio
import aiosqlite
from geopy.distance import geodesic
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
    InputMediaPhoto
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ConversationHandler
)
import telegram.error
import os

# Apply nest_asyncio for Jupyter/Notebook environments
nest_asyncio.apply()

# Logging configuration
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuration (use environment variables for sensitive data)
BOT_TOKEN = os.getenv("BOT_TOKEN", "your_bot_token_here")  # Replace with your bot token
DATABASE = os.getenv("DATABASE", "users.db")  # Database file
ADMIN_ID = 1796978458  # Admin user ID

# List of Sudanese cities (no duplicates)
SUDANESE_CITIES = [
    "Ø§Ù„Ø®Ø±Ø·ÙˆÙ…", "Ø£Ù… Ø¯Ø±Ù…Ø§Ù†", "Ø¨Ø­Ø±ÙŠ", "Ø¨ÙˆØ±ØªØ³ÙˆØ¯Ø§Ù†", "ÙƒØ³Ù„Ø§", "Ø§Ù„Ù‚Ø¶Ø§Ø±Ù", "ÙˆØ¯ Ù…Ø¯Ù†ÙŠ", "Ø§Ù„Ø£Ø¨ÙŠØ¶", "Ù†ÙŠØ§Ù„Ø§", "Ø§Ù„ÙØ§Ø´Ø±",
    "Ø¯Ù†Ù‚Ù„Ø§", "Ø¹Ø·Ø¨Ø±Ø©", "ÙƒÙˆØ³ØªÙŠ", "Ø³Ù†Ø§Ø±", "Ø§Ù„Ø¶Ø¹ÙŠÙ†", "Ø§Ù„Ø¯Ù…Ø§Ø²ÙŠÙ†", "Ø´Ù†Ø¯ÙŠ", "ÙƒØ±ÙŠÙ…Ø©", "Ø·ÙˆÙƒØ±", "Ø­Ù„ÙØ§ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©",
    "ÙˆØ§Ø¯ÙŠ Ø­Ù„ÙØ§", "Ø£Ù… Ø±ÙˆØ§Ø¨Ø©", "Ø£Ø¨Ùˆ Ø¬Ø¨ÙŠÙ‡Ø©", "Ø¨Ø§Ø¨Ù†ÙˆØ³Ø©", "Ø§Ù„Ø¬Ù†ÙŠÙ†Ø©", "Ø¬Ø²ÙŠØ±Ø© ØªÙˆØªÙŠ", "Ø§Ù„Ø­ØµØ§Ø­ÙŠØµØ§", "Ø±ÙØ§Ø¹Ø©", "Ø³Ù†Ø¬Ø©",
    "Ø§Ù„Ø±Ù†Ùƒ", "Ø­Ù„ÙØ§", "Ø§Ù„Ø­Ø¯ÙŠØ¨Ø©", "ØªÙ†Ø¯Ù„ØªÙŠ", "Ø§Ù„Ø¯Ù„Ù†Ø¬", "ÙƒØ§Ø¯ÙˆÙ‚Ù„ÙŠ", "Ø¨Ù†ØªÙŠÙˆ", "Ø§Ù„Ø±Ù‡Ø¯", "Ù†ÙˆØ±ÙŠ", "Ø£Ø±Ù‚ÙŠÙ†",
    "Ø®Ø´Ù… Ø§Ù„Ù‚Ø±Ø¨Ø©", "Ø§Ù„Ù†Ù‡ÙˆØ¯", "Ù…Ø±ÙˆÙŠ", "Ø³ÙˆØ§ÙƒÙ†", "Ø­Ù„Ø§ÙŠØ¨", "Ø£Ø¨ÙˆØ±Ù…Ø§Ø¯", "Ø¹Ø¨Ø±ÙŠ", "ÙƒØªÙ…", "Ø§Ù„Ø¶Ø¹ÙŠÙ†", "Ø§Ù„Ù…Ø¬Ù„Ø¯",
    "ÙƒØ±Ù†ÙˆÙŠ", "Ø²Ø§Ù„Ù†Ø¬ÙŠ"
]

# Registration steps
USERNAME, NAME, AGE, BIO, TYPE, CITY, LOCATION, PHOTO = range(8)

# Initialize the database
async def init_db():
    try:
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute(
                """CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY,
                    username TEXT UNIQUE,
                    name TEXT,
                    age INTEGER,
                    bio TEXT,
                    type TEXT,
                    location TEXT,
                    photo TEXT,
                    city TEXT,
                    banned INTEGER DEFAULT 0,
                    frozen INTEGER DEFAULT 0,
                    admin INTEGER DEFAULT 0
                )"""
            )
            await db.commit()
            logger.info("Database initialized successfully.")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")

# Start command (displays privacy note and starts registration)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logger.info("Start function called.")
    user_id = update.message.from_user.id
    logger.info(f"User {user_id} started registration.")

    # Display the privacy note
    privacy_note = (
        "Ù†ÙˆØ¯ Ø¥Ø¹Ù„Ø§Ù…Ùƒ Ø£Ù†Ù†Ø§ Ù†Ø­Ø±Øµ Ø¹Ù„Ù‰ Ø­Ù…Ø§ÙŠØ© Ø®ØµÙˆØµÙŠØªÙƒ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙØ¶Ù„ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„ØªØ´ÙÙŠØ± ÙˆØ§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¢Ù…Ù†. "
        "Ù„Ù† ÙŠØªÙ… Ù…Ø´Ø§Ø±ÙƒØ© Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù…Ø¹ Ø£ÙŠ Ø£Ø·Ø±Ø§Ù Ø®Ø§Ø±Ø¬ÙŠØ©.\n\n"
        "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„."
    )

    # Create a button to start registration
    keyboard = [[InlineKeyboardButton("Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„", callback_data="agree_to_privacy")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Send the privacy note with the button
    await update.message.reply_text(privacy_note, reply_markup=reply_markup)
    logger.info("Start function completed.")
    return USERNAME

# Handle the user's agreement to the privacy note
async def agree_to_privacy(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    # Start the registration process
    await query.edit_message_text("ğŸ“ Ø¨Ø¯Ø£Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„!\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:")
    return USERNAME

# Set username
async def set_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    username = update.message.text.strip()
    if not username:
        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… ØµØ­ÙŠØ­.")
        return USERNAME

    # Check if username already exists
    try:
        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = await cursor.fetchone()
            if existing_user:
                await update.message.reply_text("âŒ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ø³Ù… Ø¢Ø®Ø±.")
                return USERNAME
    except Exception as e:
        logger.error(f"Error checking username: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        return USERNAME

    context.user_data['username'] = username
    await update.message.reply_text("ğŸ’¬ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ø³Ù…Ùƒ Ø§Ù„ÙƒØ§Ù…Ù„:")
    return NAME

# Set name
async def set_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    name = update.message.text.strip()
    if not name:
        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… ØµØ­ÙŠØ­.")
        return NAME

    context.user_data['name'] = name
    await update.message.reply_text("ğŸ“… Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø¹Ù…Ø±Ùƒ:")
    return AGE

# Set age
async def set_age(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        age = int(update.message.text.strip())
        if age < 18 or age > 100:
            await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù…Ø± ØµØ­ÙŠØ­ Ø¨ÙŠÙ† 18 Ùˆ 100.")
            return AGE
        context.user_data['age'] = age
        await update.message.reply_text("ğŸ–‹ï¸ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ù†Ø¨Ø°Ø© Ù‚ØµÙŠØ±Ø© Ø¹Ù†Ùƒ:")
        return BIO
    except ValueError:
        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù…Ø± ØµØ­ÙŠØ­.")
        return AGE

# Set bio
async def set_bio(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    bio = update.message.text.strip()
    if not bio:
        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù†Ø¨Ø°Ø© ØµØ­ÙŠØ­Ø©.")
        return BIO

    context.user_data['bio'] = bio
    keyboard = [
        [InlineKeyboardButton("Ø³Ø§Ù„Ø¨", callback_data="Ø³Ø§Ù„Ø¨")],
        [InlineKeyboardButton("Ù…ÙˆØ¬Ø¨", callback_data="Ù…ÙˆØ¬Ø¨")],
        [InlineKeyboardButton("Ù…Ø¨Ø§Ø¯Ù„", callback_data="Ù…Ø¨Ø§Ø¯Ù„")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("ğŸ”„ Ø§Ø®ØªØ± Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:", reply_markup=reply_markup)
    return TYPE

# Set type
async def set_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['type'] = query.data
    await query.edit_message_text(f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹: {query.data}")

    # Create buttons for Sudanese cities
    keyboard = [[InlineKeyboardButton(city, callback_data=f"city_{city}")] for city in SUDANESE_CITIES]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("ğŸ™ï¸ Ø§Ø®ØªØ± Ù…Ø¯ÙŠÙ†ØªÙƒ:", reply_markup=reply_markup)
    return CITY

# Set city
async def set_city(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    city = query.data.split('_')[1]  # Extract city name from callback data
    context.user_data['city'] = city
    await query.edit_message_text(f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©: {city}")
    await query.message.reply_text("ğŸ“ Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ù…ÙˆÙ‚Ø¹Ùƒ Ø¨Ù…Ø´Ø§Ø±ÙƒØªÙ‡ Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ù‡Ø§ØªÙÙƒ:")
    return LOCATION

# Set location
async def set_location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.location:
        lat = update.message.location.latitude
        lon = update.message.location.longitude
        if -90 <= lat <= 90 and -180 <= lon <= 180:
            context.user_data['location'] = f"{lat},{lon}"
            await update.message.reply_text("ğŸ“· Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ ØµÙˆØ±ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©:")
            return PHOTO
        else:
            await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹ ØµØ­ÙŠØ­.")
            return LOCATION
    else:
        await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙÙŠ Ù‡Ø§ØªÙÙƒ.")
        return LOCATION

# Set photo
async def set_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        if not update.message.photo:
            await update.message.reply_text("âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© ØµØ­ÙŠØ­Ø©.")
            return PHOTO

        photo_file = update.message.photo[-1].file_id
        context.user_data['photo'] = photo_file

        # Save user data to the database
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute(
                "INSERT OR REPLACE INTO users (id, username, name, age, bio, type, location, photo, city) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (update.message.from_user.id,
                 context.user_data['username'],
                 context.user_data['name'],
                 context.user_data['age'],
                 context.user_data['bio'],
                 context.user_data['type'],
                 context.user_data['location'],
                 context.user_data['photo'],
                 context.user_data['city'])
            )
            await db.commit()

        await update.message.reply_text("âœ… ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­!")

        # Automatically show nearby profiles after registration
        await show_nearby_profiles(update, context)
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Error in set_photo: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        return ConversationHandler.END

# Show nearby profiles
async def show_nearby_profiles(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_location = context.user_data.get('location')
    user_city = context.user_data.get('city')
    if not user_location or not user_city:
        await update.message.reply_text("â— Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /start Ù„ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹Ùƒ ÙˆÙ…Ø¯ÙŠÙ†ØªÙƒ.")
        return

    user_coords = tuple(map(float, user_location.split(',')))
    try:
        async with aiosqlite.connect(DATABASE) as db:
            async with db.execute("SELECT * FROM users WHERE id != ? AND banned = 0", (update.message.from_user.id,)) as cursor:
                profiles = []
                async for row in cursor:
                    profile_coords = tuple(map(float, row[6].split(',')))
                    distance = geodesic(user_coords, profile_coords).km
                    profiles.append({
                        "id": row[0],
                        "name": row[2],
                        "age": row[3],
                        "type": row[5],
                        "city": row[8],
                        "distance": distance
                    })

                # Sort profiles: same city first, then by distance
                profiles.sort(key=lambda x: (x['city'] != user_city, x['distance']))

                # Create buttons for nearby profiles
                keyboard = []
                for profile in profiles:
                    if profile['distance'] <= 50:  # Only show profiles within 50 km
                        button_text = f"{profile['name']}, {profile['age']} Ø³Ù†Ø© - {profile['type']} ({round(profile['distance'], 1)} ÙƒÙ…)"
                        if profile['city'] == user_city:
                            button_text += " ğŸ™ï¸"
                        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"profile_{profile['id']}")])

                if keyboard:
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text("ğŸ” Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù‚Ø±ÙŠØ¨ÙˆÙ† Ù…Ù†Ùƒ:", reply_markup=reply_markup)
                else:
                    await update.message.reply_text("ğŸ˜” Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„ÙØ§Øª Ù‚Ø±ÙŠØ¨Ø©.")
    except Exception as e:
        logger.error(f"Error in show_nearby_profiles: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

# Set bot commands
async def set_bot_commands(application):
    commands = [
        ("start", "Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„"),
        ("search", "Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù‚Ø±ÙŠØ¨ÙŠÙ†"),
    ]
    await application.bot.set_my_commands(commands)

# Delete webhook
async def delete_webhook(application):
    await application.bot.delete_webhook()

# Main function
def main() -> None:
    application = ApplicationBuilder().token(BOT_TOKEN).build()

    # Delete webhook before starting polling
    application.post_init = delete_webhook

    # Set bot commands
    application.post_init = set_bot_commands

    # Conversation handler for registration
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_username)],
            NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_name)],
            AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_age)],
            BIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_bio)],
            TYPE: [CallbackQueryHandler(set_type)],  # Removed per_message=True
            CITY: [CallbackQueryHandler(set_city)],  # Removed per_message=True
            LOCATION: [MessageHandler(filters.LOCATION, set_location)],
            PHOTO: [MessageHandler(filters.PHOTO, set_photo)],
        },
        fallbacks=[CommandHandler('cancel', lambda update, context: ConversationHandler.END)],
    )

    # Add handlers
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler('search', show_nearby_profiles))
    application.add_handler(CallbackQueryHandler(agree_to_privacy, pattern="^agree_to_privacy$"))

    # Run the bot
    application.run_polling()

if __name__ == '__main__':
    asyncio.run(init_db())  # Initialize the database
    main()
