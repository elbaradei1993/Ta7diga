import logging
import asyncio
import nest_asyncio
import aiosqlite
import math
from datetime import datetime, timedelta
from telegram import (
    InlineKeyboardButton, 
    InlineKeyboardMarkup, 
    Update,
    KeyboardButton,
    ReplyKeyboardMarkup,
    Location
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters
)

# Configure environment
nest_asyncio.apply()
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Constants
BOT_TOKEN = "7886313661:AAHIUtFWswsx8UhF8wotUh2ROHu__wkgrak"  # Replace with your bot token
DATABASE = "users.db"
ADMIN_ID = 123456789  # Replace with your Telegram user ID for admin features
PHOTO_PROMPT = "ðŸ“¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø´Ø®ØµÙŠØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):\n(ÙŠÙ…ÙƒÙ†Ùƒ ØªØ®Ø·ÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø®Ø·ÙˆØ© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡)"
SKIP_PHOTO_BUTTON = [[InlineKeyboardButton("ØªØ®Ø·ÙŠ Ø§Ù„ØµÙˆØ±Ø©", callback_data="skip_photo")]]

# Helper function to calculate distance between two coordinates
def calculate_distance(lat1, lon1, lat2, lon2):
    # Haversine formula to calculate distance in kilometers
    R = 6371  # Earth radius in km
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (math.sin(dlat / 2) ** 2 
         + math.cos(math.radians(lat1)) 
         * math.cos(math.radians(lat2)) 
         * math.sin(dlon / 2) ** 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c

# Database initialization
async def init_db():
    async with aiosqlite.connect(DATABASE) as db:
        # Create users table (if it doesn't exist)
        await db.execute("""CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            username TEXT,
            name TEXT,
            age INTEGER,
            bio TEXT,
            type TEXT,
            lat REAL,
            lon REAL,
            photo TEXT,
            last_active DATETIME  -- Track the last active time
        )""")

        # Create reports table
        await db.execute("""CREATE TABLE IF NOT EXISTS reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            reporter_id INTEGER,
            reported_user_id INTEGER,
            resolved BOOLEAN DEFAULT FALSE,  -- Track if the report is resolved
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )""")

        # Create feedback table
        await db.execute("""CREATE TABLE IF NOT EXISTS feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )""")

        await db.commit()

# Update user activity
async def update_user_activity(user_id: int):
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute("UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE id = ?", (user_id,))
        await db.commit()

# Check if a user is online
async def is_user_online(user_id: int) -> bool:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute("SELECT last_active FROM users WHERE id = ?", (user_id,))
        last_active = await cursor.fetchone()

    if not last_active or not last_active[0]:
        return False

    last_active_time = datetime.strptime(last_active[0], "%Y-%m-%d %H:%M:%S")
    return datetime.now() - last_active_time < timedelta(minutes=5)

# Start command handler
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update_user_activity(update.message.from_user.id)  # Update activity
    try:
        user = update.message.from_user
        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute("SELECT * FROM users WHERE id=?", (user.id,))
            user_data = await cursor.fetchone()

        # Create inline buttons for the commands
        keyboard = [
            [InlineKeyboardButton("ðŸ›Ÿ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©", callback_data="help_command")],
            [InlineKeyboardButton("ðŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨", callback_data="delete_account")],
            [InlineKeyboardButton("ðŸ“ Ø¥Ù†Ø´Ø§Ø¡/ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ", callback_data="edit_profile")],
            [InlineKeyboardButton("ðŸš¨ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…", callback_data="report_user")],
            [InlineKeyboardButton("ðŸ“© Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ø§Ø­Ø¸Ø§Øª", callback_data="feedback")],
            [InlineKeyboardButton("ðŸ“ Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù…ÙˆÙ‚Ø¹", callback_data="share_location")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "âœ¨ Ù…Ø±Ø­Ø¨Ø§! Ø§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:",
            reply_markup=reply_markup
        )
    except Exception as e:
        logger.error(f"Start command error: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

# Help command
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update_user_activity(update.message.from_user.id)  # Update activity
    try:
        help_text = (
            "ðŸ›Ÿ *ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª:*\n\n"
            "1. Ø§Ø¨Ø¯Ø£ Ø¨ØªØ³Ø¬ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø± /start.\n"
            "2. Ø´Ø§Ø±Ùƒ Ù…ÙˆÙ‚Ø¹Ùƒ Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø±ÙŠØ¨ÙŠÙ†.\n"
            "3. ØªØµÙØ­ Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø±ÙŠØ¨ÙŠÙ† ÙˆØ§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª.\n"
            "4. Ø§Ø³ØªØ®Ø¯Ù… /update Ù„ØªØ­Ø¯ÙŠØ« Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ.\n"
            "5. Ø§Ø³ØªØ®Ø¯Ù… /delete Ù„Ø­Ø°Ù Ø­Ø³Ø§Ø¨Ùƒ.\n"
            "6. Ø§Ø³ØªØ®Ø¯Ù… /report Ù„Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù….\n"
            "7. Ø§Ø³ØªØ®Ø¯Ù… /feedback Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ.\n\n"
            "ðŸ“Œ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù‚Ø±ÙŠØ¨ÙŠÙ† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± 'ðŸ”„ ØªØ­Ø¯ÙŠØ«'."
        )
        await update.reply_text(help_text, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Help command error: {e}")
        await update.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

# Delete account command
async def delete_account(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update_user_activity(update.from_user.id)  # Update activity
    try:
        user = update.from_user
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute("DELETE FROM users WHERE id=?", (user.id,))
            await db.commit()
        await update.reply_text("âœ… ØªÙ… Ø­Ø°Ù Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!")
    except Exception as e:
        logger.error(f"Delete account error: {e}")
        await update.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

# Report user command
async def report_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update_user_activity(update.from_user.id)  # Update activity
    try:
        await update.reply_text("ðŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù†Ù‡:")
        context.user_data["report_stage"] = "user_id"
    except Exception as e:
        logger.error(f"Report user error: {e}")
        await update.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

# Feedback command
async def feedback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update_user_activity(update.from_user.id)  # Update activity
    try:
        await update.reply_text("ðŸ“ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ø£Ùˆ Ø§Ù‚ØªØ±Ø§Ø­Ø§ØªÙƒ:")
        context.user_data["feedback_stage"] = "message"
    except Exception as e:
        logger.error(f"Feedback command error: {e}")
        await update.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")

# Broadcast command (Admin Only)
async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_ID:
        await update.message.reply_text("âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±.")
        return
    await update.message.reply_text("ðŸ“¢ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¨Ø«Ù‡Ø§:")
    context.user_data["broadcast_stage"] = "message"

# Handle broadcast messages
async def handle_broadcast_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        broadcast_message = update.message.text
        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute("SELECT id FROM users")
            users = await cursor.fetchall()
        for user in users:
            try:
                await context.bot.send_message(chat_id=user[0], text=broadcast_message)
            except Exception as e:
                logger.error(f"Failed to send broadcast to user {user[0]}: {e}")
        await update.message.reply_text("âœ… ØªÙ… Ø¨Ø« Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­!")
        context.user_data.clear()
    except Exception as e:
        logger.error(f"Broadcast error: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø«ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

# Admin command to view unresolved reports
async def view_reports(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_ID:
        await update.message.reply_text("âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø©!")
        return

    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute("SELECT * FROM reports WHERE resolved = FALSE")
        reports = await cursor.fetchall()

    if not reports:
        await update.message.reply_text("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ‚Ø§Ø±ÙŠØ± ØºÙŠØ± Ù…Ø­Ù„ÙˆÙ„Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.")
        return

    report_list = "\n".join([f"ðŸ“œ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ID: {r[0]}, ðŸ‘¤ Ø§Ù„Ù…ÙØ¨Ù„Øº: {r[1]}, ðŸš© Ø§Ù„Ù…ÙØ¨Ù„Øº Ø¹Ù†Ù‡: {r[2]}, ðŸ•’ Ø§Ù„ÙˆÙ‚Øª: {r[4]}" for r in reports])
    await update.message.reply_text(f"ðŸ“œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± ØºÙŠØ± Ø§Ù„Ù…Ø­Ù„ÙˆÙ„Ø©:\n\n{report_list}")

# Admin command to resolve a report
async def resolve_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.from_user.id != ADMIN_ID:
        await update.message.reply_text("âŒ Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø©!")
        return

    try:
        report_id = context.args[0]
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute("UPDATE reports SET resolved = TRUE WHERE id = ?", (report_id,))
            await db.commit()

        await update.message.reply_text(f"âœ… ØªÙ… Ø­Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ID: {report_id}.")
    except Exception as e:
        logger.error(f"Resolve report error: {e}")
        await update.message.reply_text("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

# Main function
async def main():
    await init_db()
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    
    # Add all command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("delete", delete_account))
    app.add_handler(CommandHandler("update", edit_profile))  # Fixed: Changed update_profile to edit_profile
    app.add_handler(CommandHandler("report", report_user))
    app.add_handler(CommandHandler("feedback", feedback))
    app.add_handler(CommandHandler("broadcast", broadcast))
    app.add_handler(CommandHandler("stats", stats))  # Admin stats command
    app.add_handler(CommandHandler("reports", view_reports))  # Admin command to view reports
    app.add_handler(CommandHandler("resolve", resolve_report))  # Admin command to resolve reports
    
    # Add all message handlers
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))  # Photo handler
    app.add_handler(MessageHandler(filters.LOCATION, handle_location))  # Location handler
    app.add_handler(CallbackQueryHandler(handle_button))
    
    await app.run_polling()

if __name__ == "__main__":
    asyncio.run(main())
