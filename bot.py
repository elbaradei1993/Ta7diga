import logging
import asyncio
import nest_asyncio
import aiosqlite
from geopy.distance import geodesic
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
    InputMediaPhoto
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ConversationHandler
)
import telegram.error
import os

# Apply nest_asyncio for Jupyter/Notebook environments
nest_asyncio.apply()

# Logging configuration
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuration (use environment variables for sensitive data)
BOT_TOKEN = os.getenv("BOT_TOKEN", "your_bot_token_here")  # Replace with your bot token
DATABASE = os.getenv("DATABASE", "users.db")  # Database file
ADMIN_ID = 1796978458  # Admin user ID

# List of Sudanese cities (no duplicates)
SUDANESE_CITIES = [
    "ÿßŸÑÿÆÿ±ÿ∑ŸàŸÖ", "ÿ£ŸÖ ÿØÿ±ŸÖÿßŸÜ", "ÿ®ÿ≠ÿ±Ÿä", "ÿ®Ÿàÿ±ÿ™ÿ≥ŸàÿØÿßŸÜ", "ŸÉÿ≥ŸÑÿß", "ÿßŸÑŸÇÿ∂ÿßÿ±ŸÅ", "ŸàÿØ ŸÖÿØŸÜŸä", "ÿßŸÑÿ£ÿ®Ÿäÿ∂", "ŸÜŸäÿßŸÑÿß", "ÿßŸÑŸÅÿßÿ¥ÿ±",
    "ÿØŸÜŸÇŸÑÿß", "ÿπÿ∑ÿ®ÿ±ÿ©", "ŸÉŸàÿ≥ÿ™Ÿä", "ÿ≥ŸÜÿßÿ±", "ÿßŸÑÿ∂ÿπŸäŸÜ", "ÿßŸÑÿØŸÖÿßÿ≤ŸäŸÜ", "ÿ¥ŸÜÿØŸä", "ŸÉÿ±ŸäŸÖÿ©", "ÿ∑ŸàŸÉÿ±", "ÿ≠ŸÑŸÅÿß ÿßŸÑÿ¨ÿØŸäÿØÿ©",
    "ŸàÿßÿØŸä ÿ≠ŸÑŸÅÿß", "ÿ£ŸÖ ÿ±Ÿàÿßÿ®ÿ©", "ÿ£ÿ®Ÿà ÿ¨ÿ®ŸäŸáÿ©", "ÿ®ÿßÿ®ŸÜŸàÿ≥ÿ©", "ÿßŸÑÿ¨ŸÜŸäŸÜÿ©", "ÿ¨ÿ≤Ÿäÿ±ÿ© ÿ™Ÿàÿ™Ÿä", "ÿßŸÑÿ≠ÿµÿßÿ≠Ÿäÿµÿß", "ÿ±ŸÅÿßÿπÿ©", "ÿ≥ŸÜÿ¨ÿ©",
    "ÿßŸÑÿ±ŸÜŸÉ", "ÿ≠ŸÑŸÅÿß", "ÿßŸÑÿ≠ÿØŸäÿ®ÿ©", "ÿ™ŸÜÿØŸÑÿ™Ÿä", "ÿßŸÑÿØŸÑŸÜÿ¨", "ŸÉÿßÿØŸàŸÇŸÑŸä", "ÿ®ŸÜÿ™ŸäŸà", "ÿßŸÑÿ±ŸáÿØ", "ŸÜŸàÿ±Ÿä", "ÿ£ÿ±ŸÇŸäŸÜ",
    "ÿÆÿ¥ŸÖ ÿßŸÑŸÇÿ±ÿ®ÿ©", "ÿßŸÑŸÜŸáŸàÿØ", "ŸÖÿ±ŸàŸä", "ÿ≥ŸàÿßŸÉŸÜ", "ÿ≠ŸÑÿßŸäÿ®", "ÿ£ÿ®Ÿàÿ±ŸÖÿßÿØ", "ÿπÿ®ÿ±Ÿä", "ŸÉÿ™ŸÖ", "ÿßŸÑÿ∂ÿπŸäŸÜ", "ÿßŸÑŸÖÿ¨ŸÑÿØ",
    "ŸÉÿ±ŸÜŸàŸä", "ÿ≤ÿßŸÑŸÜÿ¨Ÿä"
]

# Registration steps
USERNAME, NAME, AGE, BIO, TYPE, CITY, LOCATION, PHOTO = range(8)

# Initialize the database
async def init_db():
    try:
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute(
                """CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY,
                    username TEXT UNIQUE,
                    name TEXT,
                    age INTEGER,
                    bio TEXT,
                    type TEXT,
                    location TEXT,
                    photo TEXT,
                    city TEXT,
                    banned INTEGER DEFAULT 0,
                    frozen INTEGER DEFAULT 0,
                    admin INTEGER DEFAULT 0
                )"""
            )
            await db.commit()
            logger.info("Database initialized successfully.")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")

# Start command (displays privacy note and starts registration)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logger.info("Start function called.")
    user_id = update.message.from_user.id
    logger.info(f"User {user_id} started registration.")

    # Display the privacy note
    privacy_note = (
        "ŸÜŸàÿØ ÿ•ÿπŸÑÿßŸÖŸÉ ÿ£ŸÜŸÜÿß ŸÜÿ≠ÿ±ÿµ ÿπŸÑŸâ ÿ≠ŸÖÿßŸäÿ© ÿÆÿµŸàÿµŸäÿ™ŸÉ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ£ŸÅÿ∂ŸÑ ÿ™ŸÇŸÜŸäÿßÿ™ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ± ŸàÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ¢ŸÖŸÜ. "
        "ŸÑŸÜ Ÿäÿ™ŸÖ ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÖÿπ ÿ£Ÿä ÿ£ÿ∑ÿ±ÿßŸÅ ÿÆÿßÿ±ÿ¨Ÿäÿ©.\n\n"
        "ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ≤ÿ± ÿ£ÿØŸÜÿßŸá ŸÑÿ®ÿØÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ."
    )

    # Create a button to start registration
    keyboard = [[InlineKeyboardButton("ÿ®ÿØÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ", callback_data="agree_to_privacy")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Send the privacy note with the button
    await update.message.reply_text(privacy_note, reply_markup=reply_markup)
    logger.info("Start function completed.")
    return USERNAME

# Handle the user's agreement to the privacy note
async def agree_to_privacy(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    # Start the registration process
    await query.edit_message_text("üìù ÿ®ÿØÿ£ÿ™ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ!\nÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ:")
    return USERNAME

# Set username
async def set_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    username = update.message.text.strip()
    if not username:
        await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿµÿ≠Ÿäÿ≠.")
        return USERNAME

    # Check if username already exists
    try:
        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute("SELECT id FROM users WHERE username = ?", (username,))
            existing_user = await cursor.fetchone()
            if existing_user:
                await update.message.reply_text("‚ùå ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàÿ¨ŸàÿØ ÿ®ÿßŸÑŸÅÿπŸÑ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßÿ≥ŸÖ ÿ¢ÿÆÿ±.")
                return USERNAME
    except Exception as e:
        logger.error(f"Error checking username: {e}")
        await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")
        return USERNAME

    context.user_data['username'] = username
    await update.message.reply_text("üí¨ ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿßÿ≥ŸÖŸÉ ÿßŸÑŸÉÿßŸÖŸÑ:")
    return NAME

# Set name
async def set_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    name = update.message.text.strip()
    if not name:
        await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿµÿ≠Ÿäÿ≠.")
        return NAME

    context.user_data['name'] = name
    await update.message.reply_text("üìÖ ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿπŸÖÿ±ŸÉ:")
    return AGE

# Set age
async def set_age(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        age = int(update.message.text.strip())
        if age < 18 or age > 100:
            await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿπŸÖÿ± ÿµÿ≠Ÿäÿ≠ ÿ®ŸäŸÜ 18 Ÿà 100.")
            return AGE
        context.user_data['age'] = age
        await update.message.reply_text("üñãÔ∏è ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÜÿ®ÿ∞ÿ© ŸÇÿµŸäÿ±ÿ© ÿπŸÜŸÉ:")
        return BIO
    except ValueError:
        await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿπŸÖÿ± ÿµÿ≠Ÿäÿ≠.")
        return AGE

# Set bio
async def set_bio(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    bio = update.message.text.strip()
    if not bio:
        await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÜÿ®ÿ∞ÿ© ÿµÿ≠Ÿäÿ≠ÿ©.")
        return BIO

    context.user_data['bio'] = bio
    keyboard = [
        [InlineKeyboardButton("ÿ≥ÿßŸÑÿ®", callback_data="ÿ≥ÿßŸÑÿ®")],
        [InlineKeyboardButton("ŸÖŸàÿ¨ÿ®", callback_data="ŸÖŸàÿ¨ÿ®")],
        [InlineKeyboardButton("ŸÖÿ®ÿßÿØŸÑ", callback_data="ŸÖÿ®ÿßÿØŸÑ")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üîÑ ÿßÿÆÿ™ÿ± ÿßŸÑŸÜŸàÿπ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ:", reply_markup=reply_markup)
    return TYPE

# Set type
async def set_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    context.user_data['type'] = query.data
    await query.edit_message_text(f"‚úÖ ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÜŸàÿπ: {query.data}")

    # Create buttons for Sudanese cities
    keyboard = [[InlineKeyboardButton(city, callback_data=f"city_{city}")] for city in SUDANESE_CITIES]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("üèôÔ∏è ÿßÿÆÿ™ÿ± ŸÖÿØŸäŸÜÿ™ŸÉ:", reply_markup=reply_markup)
    return CITY

# Set city
async def set_city(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    city = query.data.split('_')[1]  # Extract city name from callback data
    context.user_data['city'] = city
    await query.edit_message_text(f"‚úÖ ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖÿØŸäŸÜÿ©: {city}")
    await query.message.reply_text("üìç ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ŸÖŸàŸÇÿπŸÉ ÿ®ŸÖÿ¥ÿßÿ±ŸÉÿ™Ÿá ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖŸÜ Ÿáÿßÿ™ŸÅŸÉ:")
    return LOCATION

# Set location
async def set_location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.location:
        lat = update.message.location.latitude
        lon = update.message.location.longitude
        if -90 <= lat <= 90 and -180 <= lon <= 180:
            context.user_data['location'] = f"{lat},{lon}"
            await update.message.reply_text("üì∑ ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿµŸàÿ±ÿ™ŸÉ ÿßŸÑÿ¥ÿÆÿµŸäÿ©:")
            return PHOTO
        else:
            await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÖŸàŸÇÿπ ÿµÿ≠Ÿäÿ≠.")
            return LOCATION
    else:
        await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÖŸàŸÇÿπŸÉ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ≤ÿ± ÿßŸÑŸÖŸàŸÇÿπ ŸÅŸä Ÿáÿßÿ™ŸÅŸÉ.")
        return LOCATION

# Set photo
async def set_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        if not update.message.photo:
            await update.message.reply_text("‚ùå ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿµŸàÿ±ÿ© ÿµÿ≠Ÿäÿ≠ÿ©.")
            return PHOTO

        photo_file = update.message.photo[-1].file_id
        context.user_data['photo'] = photo_file

        # Save user data to the database
        async with aiosqlite.connect(DATABASE) as db:
            await db.execute(
                "INSERT OR REPLACE INTO users (id, username, name, age, bio, type, location, photo, city) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (update.message.from_user.id,
                 context.user_data['username'],
                 context.user_data['name'],
                 context.user_data['age'],
                 context.user_data['bio'],
                 context.user_data['type'],
                 context.user_data['location'],
                 context.user_data['photo'],
                 context.user_data['city'])
            )
            await db.commit()

        await update.message.reply_text("‚úÖ ÿ™ŸÖ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ŸÜÿ¨ÿßÿ≠!")

        # Automatically show nearby profiles after registration
        await show_nearby_profiles(update, context)
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Error in set_photo: {e}")
        await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")
        return ConversationHandler.END

# Show nearby profiles
async def show_nearby_profiles(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_location = context.user_data.get('location')
    user_city = context.user_data.get('city')
    if not user_location or not user_city:
        await update.message.reply_text("‚ùó ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ£ŸàŸÑÿßŸã ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ /start ŸÑÿ™ÿ≠ÿØŸäÿØ ŸÖŸàŸÇÿπŸÉ ŸàŸÖÿØŸäŸÜÿ™ŸÉ.")
        return

    user_coords = tuple(map(float, user_location.split(',')))
    try:
        async with aiosqlite.connect(DATABASE) as db:
            async with db.execute("SELECT * FROM users WHERE id != ? AND banned = 0", (update.message.from_user.id,)) as cursor:
                profiles = []
                async for row in cursor:
                    profile_coords = tuple(map(float, row[6].split(',')))
                    distance = geodesic(user_coords, profile_coords).km
                    profiles.append({
                        "id": row[0],
                        "name": row[2],
                        "age": row[3],
                        "type": row[5],
                        "city": row[8],
                        "distance": distance
                    })

                # Sort profiles: same city first, then by distance
                profiles.sort(key=lambda x: (x['city'] != user_city, x['distance']))

                # Create buttons for nearby profiles
                keyboard = []
                for profile in profiles:
                    if profile['distance'] <= 50:  # Only show profiles within 50 km
                        button_text = f"{profile['name']}, {profile['age']} ÿ≥ŸÜÿ© - {profile['type']} ({round(profile['distance'], 1)} ŸÉŸÖ)"
                        if profile['city'] == user_city:
                            button_text += " üèôÔ∏è"
                        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"profile_{profile['id']}")])

                if keyboard:
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text("üîç ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ÿßŸÑŸÇÿ±Ÿäÿ®ŸàŸÜ ŸÖŸÜŸÉ:", reply_markup=reply_markup)
                else:
                    await update.message.reply_text("üòî ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖŸÑŸÅÿßÿ™ ŸÇÿ±Ÿäÿ®ÿ©.")
    except Exception as e:
        logger.error(f"Error in show_nearby_profiles: {e}")
        await update.message.reply_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ®ÿ≠ÿ´. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")

# Set bot commands
async def set_bot_commands(application):
    commands = [
        ("start", "ÿ®ÿØÿ° ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ"),
        ("search", "ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÇÿ±Ÿäÿ®ŸäŸÜ"),
    ]
    await application.bot.set_my_commands(commands)

# Delete webhook
async def delete_webhook(application):
    await application.bot.delete_webhook()

# Main function
def main() -> None:
    application = ApplicationBuilder().token(BOT_TOKEN).build()

    # Delete webhook before starting polling
    application.post_init = delete_webhook

    # Set bot commands
    application.post_init = set_bot_commands

    # Conversation handler for registration
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_username)],
            NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_name)],
            AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_age)],
            BIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_bio)],
            TYPE: [CallbackQueryHandler(set_type)],  # Removed per_message=True
            CITY: [CallbackQueryHandler(set_city)],  # Removed per_message=True
            LOCATION: [MessageHandler(filters.LOCATION, set_location)],
            PHOTO: [MessageHandler(filters.PHOTO, set_photo)],
        },
        fallbacks=[CommandHandler('cancel', lambda update, context: ConversationHandler.END)],
    )

    # Add handlers
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler('search', show_nearby_profiles))
    application.add_handler(CallbackQueryHandler(agree_to_privacy, pattern="^agree_to_privacy$"))

    # Run the bot
    application.run_polling()

if __name__ == '__main__':
    asyncio.run(init_db())  # Initialize the database
    main()
